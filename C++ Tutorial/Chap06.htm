<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Gordon Dodrill">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (Win95; I) [Netscape]">
   <TITLE>Chap06</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<B>C++ Tutorial - Chapter 6</B>

<P><B><FONT SIZE=+3>M</FONT><FONT SIZE=+2>ORE</FONT><FONT SIZE=+3> E</FONT><FONT SIZE=+2>NCAPSULATION</FONT></B>

<P><B>WHY BOTHER WITH ENCAPSULATION?</B>

<P>We asked this question earlier, but now that we have a little experience,
we can provide a much better answer. Encapsulation protects data from accidental
corruption, and constructors guarantee proper initialization. Both prevent
errors that we are very prone to make since we are thinking only about
the internals of the class when we are writing it. Later, when we are actually
using the class, we have no need to concern ourselves with the internal
structure or operation, but can spend our energies using the class to solve
the overall problem we are working on. As you may guess, there is a lot
more to learn about the use and benefits of classes so we will dive right
into some new topics.

<P>The purpose of this chapter is to illustrate how to use some of the
traditional aspects of C or C++ with classes and objects. Pointers to an
object as well as pointers within an object will be illustrated. Arrays
embedded within an object, and an array of objects will be illustrated.
Since objects are simply another C++ data construct, all of these things
are possible and can be used if needed.

<P>In order to have a systematic study, we will use the program named BOXES1.CPP
from the last chapter as a starting point and we will add a few new constructs
to it for each example program. You will recall that it was a very simple
program with the class definition, the class implementation, and the main
program all in one file. This was selected as a starting point because
we will eventually make changes to all parts of the program and it will
be convenient to have it all in a single file for illustrative purposes.
It must be kept in mind however that the proper way to use these constructs
is to separate them into the three files as was illustrated in BOX.H, BOX.CPP,
and BOXES2.CPP in the last chapter. This allows the implementor of <B>box
</B>to supply the user with only the interface, namely BOX.H. Not giving
him the implementation file named BOX.CPP, is practicing the technique
of information hiding. As we have said many times, it seems silly to break
up such a small program into three separate files, and it is sort of silly.
The last chapter of this tutorial will illustrate a program large enough
to require dividing the program up into many separate files.

<P><B>AN ARRAY OF OBJECTS</B>

<P>Example program ------> <B>OBJARRAY.CPP</B>

<P>Examine the file named OBJARRAY.CPP for our first example of an array
of objects. This file is nearly identical to the file named BOX1.CPP until
we come to line 45 where an array of 4 boxes are defined.

<P>Recalling the operation of the constructor you will remember that each
of the four <B>box </B>objects will be initialized to the values defined
within the constructor since the constructor will be executed for each
<B>box </B>as they are defined. In order to define an array of objects,
a constructor for that object with no parameters must be available. (We
have not yet illustrated a constructor with initializing parameters, but
we will in the next program.) This is an efficiency consideration since
it would probably be an error to initialize all elements of an array of
objects to the same value. We will see the results of executing the constructor
when we compile and execute the file later.

<P>Line 50 defines a <B>for </B>loop that begins with 1 instead of the
normal starting index for an array leaving the first object, named <B>group[0],</B>
to use the default values stored when the constructor was called. You will
observe that sending a message to one of the objects uses the same construct
as is used for any object. The name of the array followed by its index
in square brackets is used to send a message to one of the objects in the
array. This is illustrated in line 51 and the operation of that code should
be clear to you. The other method is called in the output statement in
lines 58 and 59 where the area of the four boxes in the <B>group </B>array
are listed on the monitor.

<P>Another fine point should be mentioned. The integer variable named <B>index
</B>is defined in line 50 and is still available for use in line 57 since
we have not yet left the enclosing block which begins in line 44 and extends
to line 68. But this is true only if your compiler is aging slightly. If
you have a new compiler, you may find that <B>index </B>is undefined in
line 57. See the discussion in Chapter 1 if this is not clear.

<P><B>DECLARATION AND DEFINITION OF A VARIABLE</B>

<P>An extra variable was included for illustration, the one named <B>extra_data</B>
in line seven. Since the keyword <B>static </B>is used to modify this variable
in line 8, it is an external variable and only one copy of this variable
will ever exist. All seven objects of this class share a single copy of
this variable which is global to the objects defined in line 44.

<P>The variable is actually only declared here which says it will exist
somewhere, but it is not yet defined. A declaration says the variable will
exist and gives it a name, but the definition actually defines a place
to store it somewhere in the computers memory space. By definition, a static
variable can be declared in a class header but it cannot be defined there,
so it is usually defined in the implementation file. In this case it is
defined in line 17 and can then be used throughout the class.

<P>Figure 6-1 is a graphical representation of some of the variables. Note
that the objects named <B>large</B>, <B>group[0]</B>, <B>group[1]</B>,
and <B>group[2]</B> are not shown but they also share the variable named
<B>extra_data</B>. They are not shown in order to simplify the picture
and enhance the clarity. Each object has its own personal <B>length </B>and
<B>width </B>because they are not declared <B>static</B>.

<P><IMG SRC="Image/CPP0601.GIF" VSPACE=20 NOSAVE BORDER=0 HEIGHT=341 WIDTH=520>

<P>Line 24 of the constructor sets the single global variable to 1 each
time an object is declared. Only one assignment is necessary so the other
six are actually wasted code. It is generally not a good idea to assign
a value to a <B>static </B>member in a constructor, but in this case, it
illustrates how the static variable works. To illustrate that there is
only one variable shared by all objects of this class, the method to read
its value also increments it. Each time it is read in lines 61 through
65, it is incremented and the result of the execution proves that there
is only a single variable shared by all objects of this class. You will
also note that the method named <B>get_extra()</B> is defined within the
class declaration so it will be assembled into the final program as inline
code.

<P>You will recall the 2 static variables we declared in lines 18 and 19
of DATE.H in chapter 5 of this tutorial. We defined them in lines 9 and
10 of DATE.CPP and overlooked a complete explanation of what they did at
that time. The declaration and definition of these variables should be
considered a good example of the proper place to put these constructs in
your classes.

<P>Be sure you understand this program and especially the static variable,
then compile and execute it to see if you get the same result as listed
at the end of the program.

<P><B>A STRING WITHIN AN OBJECT</B>

<P>Example program ------> <B>OBJSTRNG.CPP</B>

<P>Examine the program named OBJSTRNG.CPP for our first example of an object
with an embedded string. Actually, the object does not have an embedded
string, it has an embedded pointer, but the two work so closely together
that we can study one and understand both.

<P>You will notice that line 8 contains a pointer to a <B>char </B>named
<B>line_of_text</B>. The constructor contains an input parameter which
is a pointer to a string which will be copied to the string named <B>line_of_text</B>
within the constructor. We could have defined the variable <B>line_of_text
</B>as an actual array in the class, then used <B>strcpy()</B> to copy
the string into the object and everything would have worked the same, but
we will leave that as an exercise for you at the end of this chapter. It
should be pointed out that we are not limited to passing a single parameter
to a constructor. Any number of parameters can be passed, as will be illustrated
later.

<P>You will notice that when the three boxes are defined this time, we
supply a string constant as an actual parameter with each declaration which
is used by the constructor to assign the string pointer some data to point
to. When we call <B>get_area() </B>in lines 50 through 54, we get the message
displayed and the area returned. It would be prudent to put these operations
in separate methods since there is no apparent connection between printing
the message and calculating the area, but it was written this way to illustrate
that it can be done. What this really says is that it is possible to have
a method that has a side effect, the message output to the monitor, and
a return value, the area of the box. However, as we discussed in chapter
4 when we studied DEFAULT.CPP, the order of evaluation is sort of funny,
so we broke each line into two lines.

<P>After you understand this program, compile and execute it.

<P><B>AN OBJECT WITH AN INTERNAL POINTER</B>

<P>Example programs ------> <B>OBJINTPT.CPP</B>

<P>The program named OBJINTPT.CPP is our first example program with an
embedded pointer which will be used for dynamic allocation of data.

<P>In line 8 we declare a pointer to an integer variable, but it is only
a pointer, there is no storage associated with it. The constructor therefore
allocates an integer type variable on the heap for use with this pointer
in line 22. It should be clear to you that the three objects defined in
line 46 each contain a pointer which points into the heap to three different
locations. Each object has its own dynamically allocated variable for its
own private use. Moreover each has a value of 112 stored in its dynamically
allocated data because line 23 stores that value in each of the three locations,
once for each call to the constructor.

<P>In such a small program, there is no chance that we will exhaust the
heap, so no test is made for unavailable memory. In a real production program,
it would be mandatory to test that the value of the returned pointer is
not NULL to assure that the data actually did get allocated.

<P>The method named <B>set()</B> has three parameters associated with it
and the third parameter is used to set the value of the new dynamically
allocated variable. There are two messages passed, one to the small box
and one to the large box. As before, the medium box is left with its default
values.

<P>The three areas are displayed followed by the three stored values in
the dynamically allocated variables, and we finally have a program that
requires a destructor in order to be completely proper. If we simply leave
the scope of the objects as we do when we leave the <B>main()</B> program,
we will leave the three dynamically allocated variables on the heap with
nothing pointing to them. They will be inaccessible and will therefore
represent wasted storage on the heap. For that reason, the destructor is
used to <B>delete </B>the variable which the pointer named <B>point </B>is
referencing, as each object goes out of existence. In this case, lines
38 and 39 assign zero to variables that will be automatically deleted.
Even though these lines of code really do no good, they are legal statements.

<P>Actually, in this particular case, the variables will be automatically
reclaimed when we return to the operating system because all program cleanup
is done for us at that time. This is an illustration of good programming
practice, that of cleaning up after yourself when you no longer need some
dynamically allocated variables.

<P>One other construct should be mentioned again, that of the inline method
implementations in line 12 and 13. As we mentioned in chapter 5, inline
functions can be used where speed is of the utmost in importance since
the code is assembled inline rather than by actually making a method call.
Since the code is defined as part of the declaration, the system will assemble
it inline, and a separate implementation for these methods is not needed.
If the inline code is too involved, the compiler is allowed to ignore the
inline request and will actually assemble it as a separate method, but
it will do it invisibly to you and will probably not even tell you about
it.

<P>Remember that we are interested in using information hiding and inline
code prevents hiding of the implementation, putting it out in full view.
Many times you will be more interested in speeding up a program than you
are in hiding a trivial implementation. Since most inline methods are trivial,
you should feel free to use the inline code construct wherever it is expedient.
Be sure to compile and execute this program.

<P><B>A DYNAMICALLY ALLOCATED OBJECT</B>

<P>Example program ------> <B>OBJDYNAM.CPP</B>

<P>Examine the file named OBJDYNAM.CPP for our first look at a dynamically
allocated object. This is not any different than any other dynamically
allocated object, but an example is always helpful.

<P>In line 40 we define a pointer to an object of type <B>box </B>and since
it is only a pointer with nothing to point to, we dynamically allocate
an object for it in line 45, with the object being created on the heap
just like any other dynamically allocated variable. When the object is
created in line 45, the constructor is called automatically to assign values
to the two internal storage variables. Note that the constructor is not
called when the pointer is defined since there is nothing to initialize.
It is called when the object is allocated.

<P>Reference to the components of the object are handled in much the same
way that structure references are made, through use of the pointer operator
as illustrated in lines 51 through 53. Of course you can use the pointer
dereferencing method without the arrow such as (*point).set(12, 12); as
a replacement for line 52 but the arrow notation is much more universal
and should be used. Finally, the object is deleted in line 55 and the program
terminates. If there were a destructor for this class, it would be called
automatically as part of the <B>delete </B>statement to clean up the object
prior to deletion.

<P>You have probably noticed by this time that the use of objects is not
much different from the use of structures. Be sure to compile and execute
this program after you have studied it thoroughly.

<P><B>AN OBJECT WITH A POINTER TO ANOTHER OBJECT</B>

<P>Example program ------> <B>OBJLIST.CPP</B>

<P>The program named OBJLIST.CPP contains an object with an internal reference
to another object of its own class. This is the standard structure used
for a singly linked list and we will keep the use of it very simple in
this program.

<P>The constructor contains the statement in line 22 which assigns the
pointer the value of NULL to initialize the pointer. This is a good idea
for all of your programming, don't allow any pointer to point off into
space, but initialize all pointers to something. By assigning the pointer
within the constructor, you guarantee that every object of this class will
automatically have its pointer initialized. It will be impossible to overlook
the assignment of one of these pointers.

<P>Two additional methods are declared in lines 13 and 14 with the one
in line 14 having a construct we have not yet mentioned in this tutorial.
This method returns a pointer to an object of the <B>box </B>class. As
you are aware, you can return a pointer to a <B>struct </B>in standard
C, and this is a parallel construct in C++. The implementation in lines
49 through 52 returns the pointer stored as a member variable within the
object. We will see how this is used when we get to the actual program.

<P><IMG SRC="Image/CPP0602.GIF" HSPACE=20 VSPACE=20 NOSAVE BORDER=0 HEIGHT=342 WIDTH=434>

<P>An extra pointer named <B>box_pointer</B> is defined in the main program
for use later and in line 67 we make the embedded pointer within the <B>small
box</B> point to the <B>medium box</B>. Line 68 makes the embedded pointer
within the <B>medium box</B> point to the <B>large box.</B> We have effectively
generated a linked list with three elements. In line 70 we make the extra
pointer point to the <B>small box</B>. Continuing in line 71 we use it
to refer to the <B>small box</B> and update it to the value contained in
the <B>small box</B> which is the address of the <B>medium box</B>. We
have therefore traversed from one element of the list to another by sending
a message to one of the objects. If line 71 were repeated exactly as shown,
it would cause the extra pointer to refer to the <B>large box</B>, and
we would have traversed the entire linked list which is only composed of
three elements. Figure 6-2 is a graphical representation of the data space
following execution of line 70. Note that only a portion of each object
is actually depicted here to keep it simple.

<P><B>ANOTHER NEW KEYWORD this</B>

<P>Another new keyword is available in C++, the keyword <B>this</B>. The
word <B>this </B>is defined within any object as being a pointer to the
object in which it is contained. It is implicitly defined as;
<PRE>&nbsp;&nbsp;&nbsp; class_name *this;</PRE>
and is initialized to point to the object for which the member function
is invoked. This pointer is most useful when working with pointers and
especially with a linked list when you need to reference a pointer to the
object you are inserting into the list. The keyword <B>this </B>is available
for this purpose and can be used in any object. Actually the proper way
to refer to any variable within a list is through use of the predefined
pointer <B>this</B>, by writing <B>this->variable_name</B>, but the compiler
assumes the pointer is used, and we can simplify every reference by omitting
the pointer. Use of the keyword <B>this </B>is not illustrated in a program
at this point, but will be used in one of the larger example programs later
in this tutorial.

<P>You should study this program until you understand it completely then
compile and execute it in preparation for our next example program.

<P><B>A LINKED LIST OF OBJECTS</B>

<P>Example program ------> <B>OBJLINK.CPP</B>

<P>The next example program in this chapter is named OBJLINK.CPP and is
a complete example of a linked list written in object oriented notation.

<P>This program is very similar to the last one. In fact it is identical
until we get to the <B>main()</B> program. You will recall that in the
last program the only way we had to set or use the embedded pointer was
through use of the two methods named <B>point_at_next()</B> and <B>get_next()</B>
which are listed in lines 42 through 52 of the present program. We will
use these to build up our linked list then traverse and print the list.
Finally, we will <B>delete </B>the entire list to free the space on the
heap.

<P>In lines 57 through 59 we define three pointers for use in the program.
The pointer named <B>start </B>will always point to the beginning of the
list, but <B>temp </B>will move down through the list as we create it.
The pointer named <B>box_pointer</B> will be used for the creation of each
object. We execute the loop in lines 62 through 75 to generate the list
where line 64 dynamically allocates a new object of the <B>box class </B>and
line 65 fills it with nonsense data for illustration. If this is the first
element in the list, the <B>start </B>pointer is set to point to this element,
but if elements already exist, the <B>last </B>element in the list is assigned
to point to the new element. In either case, the <B>temp </B>pointer is
assigned to point to the last element of the list, in preparation for adding
another element if there is another element to be added.

<P>In line 78, the pointer named <B>temp </B>is caused to point to the
first element and it is used to increment its way through the list by updating
itself in line 82 during each pass through the loop. When <B>temp </B>has
the value of NULL, which it gets from the last element of the list, we
are finished traversing the list.

<P>Finally, we delete the entire list by starting at the beginning and
deleting one element each time we pass through the loop in lines 87 through
92.

<P>A careful study of the program will reveal that it does indeed generate
a linked list of ten elements, each element being an object of class <B>box</B>.
The length of this list is limited by the practicality of how large a list
we desire to print out, but it could be lengthened to many thousands of
these simple elements provided you have enough memory available to store
them all.

<P>Once again, the success of the dynamic allocation is not checked as
it should be in a correctly written program. Be sure to compile and execute
this example program.

<P><B>NESTING OBJECTS</B>

<P>Example program ------> <B>NESTING.CPP</B>

<P>Examine the program named NESTING.CPP for an example of nesting classes
which results in nested objects. A nested object could be illustrated with
your computer in a rather simple manner. The computer itself is composed
of many items which work together but work entirely differently, such as
a keyboard, a disk drive, and a power supply. The computer is composed
of these very dissimilar items and it is desirable to discuss the keyboard
separately from the disk drive because they are so different. A computer
class could be composed of several objects that are dissimilar by nesting
the dissimilar classes within the computer class.

<P>If however, we wished to discuss disk drives, we may wish to examine
the characteristics of disk drives in general, then examine the details
of a hard disk, and the differences of floppy disks. This would involve
inheritance because much of the data about both drives could be characterized
and applied to the generic disk drive then used to aid in the discussion
of the other three. We will study inheritance in the next three chapters,
but for now we will look at the embedded or nested class.

<P><IMG SRC="Image/CPP0603.GIF" HSPACE=20 VSPACE=20 NOSAVE BORDER=0 HEIGHT=357 WIDTH=374>

<P>This example program contains a class named <B>box </B>which contains
an object of another class embedded within it in line 17, the <B>mail_info</B>
class. It is depicted graphically in figure 6-3. This object is available
for use only within the class implementation of <B>box </B>because that
is where it is defined. The <B>main()</B> program has objects of class
<B>box </B>defined but no objects of class <B>mail_info</B>, so the <B>mail_info</B>
class cannot be referred to in the <B>main()</B> program. In this case,
the <B>mail_info</B> class object is meant to be used internally to the
<B>box </B>class and one example is given in line 22 where a message is
sent to the <B>label.set() </B>method to initialize the variables. Additional
methods could be used as needed, but these are given as an illustration
of how they can be called.

<P>Of prime importance is the fact that there are never any objects of
the <B>mail_info</B> class declared directly in the <B>main() </B>program,
they are inherently declared when the enclosing objects of <B>class box</B>
are declared. Of course objects of the <B>mail_info</B> class could be
declared and used in the <B>main()</B> program if needed, but they are
not in this example program. In order to be complete, the <B>box </B>class
should have one or more methods to use the information stored in the object
of the <B>mail_info</B> class. Study this program until you understand
the new construct, then compile and execute it.

<P>If the class and the nested classes require parameter lists for their
respective constructors an initialization list can be given. This will
be discussed and illustrated later in this tutorial.

<P><B>OPERATOR OVERLOADING</B>

<P>Example program ------> <B>OPOVERLD.CPP</B>

<P>The example file named OPOVERLD.CPP contains examples of overloading
operators. This allows you to define a class of objects and redefine the
use of the normal operators. The end result is that objects of the new
class can be used in as natural a manner as the predefined types. In fact,
they seem to be a part of the language rather than your own add-on.

<P>In this case we overload the + operator and the * operator, with the
declarations in lines 11 through 13, and the definitions in lines 17 through
41. The methods are declared as <B>friend </B>functions so we can use the
double parameter functions as listed. If we did not use the friend construct,
the function would be a part of one of the objects and that object would
be the object to which the message was sent. Including the <B>friend </B>construct
allows us to separate this method from the object and call the method with
infix notation. Using this technique, it can be written as <B>object1 +
object2</B> rather than <B>object1.operator+(object2)</B>. Also, without
the <B>friend </B>construct we could not use an overloading with an <B>int
</B>type variable for the first parameter because we can not send a message
to an integer type variable such as <B>int.operator+(object)</B>. Two of
the three operator overloadings use an <B>int </B>for the first parameter
so it is necessary to declare them as friend functions.

<P>There is no upper limit to the number of overloadings for any given
operator. Any number of overloadings can be used provided the parameters
are different for each particular overloading.

<P>The header in line 17 illustrates the first overloading where the +
operator is overloaded by giving the return type followed by the keyword
operator and the operator we wish to overload. The two formal parameters
and their types are then listed in the parentheses and the normal function
operations are given in the implementation of the function in lines 19
through 22. The observant student will notice that the implementation of
the <B>friend </B>functions are not actually a part of the class because
the class name is not prepended onto the method name in line 17. There
is nothing unusual about this implementation, it should be easily understood
by you at this point. For purposes of illustration, some silly mathematics
are performed in the method implementation, but any desired operations
can be done.

<P>The biggest difference occurs in line 57 where this method is called
by using the infix notation instead of the usual message sending format.
Since the variables <B>small </B>and <B>medium </B>are objects of the <B>box
</B>class, the system will search for a way to use the + operator on two
objects of class <B>box </B>and will find it in the overloaded <B>operator+</B>
method we have just discussed. The operations within the method implementation
can be anything we need them to be, and they are usually much more meaningful
than the silly math included here.

<P>In line 59 we ask the system to add an <B>int </B>type constant to an
object of class <B>box</B>, so the system finds the other overloading of
the + operator beginning in line 26 to perform this operation. Also in
line 61 we ask the system to use the * operator to do something to an <B>int
</B>constant and an object of class <B>box</B>, which it satisfies by finding
the method in lines 35 through 41. Note that it would be illegal to attempt
to use the * operator the other way around, namely <B>large * 4</B> since
we did not define a method to use the two types in that order. Another
overloading could be given with reversed types, and we could then use the
reverse order in a program.

<P>You will notice that when using operator overloading, we are also using
function name overloading since some of the function names are the same.

<P>When we use operator overloading in this manner, we actually make our
programs look like the class is a natural part of the language since it
is integrated into the language so well. C++ is therefore an extendible
language and can be molded to fit the mechanics of the problem at hand.

<P><B>OPERATOR OVERLOADING CAVEATS</B>

<P>Each new topic we study has its pitfalls which must be warned against
and the topic of operator overloading seems to have the record for pitfalls
since it is so prone to misuse and has several problems. The overloading
of operators is only available for classes, you cannot redefine the operators
for the predefined simple types. This would probably be very silly anyway
since the code could be very difficult to read if you changed some of them
around.

<P>The logical and "&amp;&amp;" and the logical or "||" operators can be
overloaded for the classes you define, but they will not operate as short
circuit operators. All members of the logical construction will be evaluated
with no regard concerning the outcome. Of course the normal predefined
logical operators will continue to operate as short circuit operators as
expected, but not the overloaded ones.

<P>If the increment "++" or decrement "--" operators are overloaded, the
system has no way of telling whether the operators are used as preincrement
or postincrement (or predecrement or postdecrement) operators. Which method
is used is implementation dependent, so you should use them in such a way
that it doesn't matter which is used.

<P>Be sure to compile and execute OPOVERLD.CPP before continuing on to
the next example program.

<P><B>FUNCTION OVERLOADING IN A CLASS</B>

<P>Example program ------><B> FUNCOVER.CPP</B>

<P>Examine the program named FUNCOVER.CPP for an example of function name
overloading within a class. In this program the constructor is overloaded
as well as one of the methods to illustrate what can be done.

<P>This file illustrates some of the uses of overloaded names and a few
of the rules for their use. You will recall that the function selected
is based on the number and types of the formal parameters only. The type
of the return value is not significant in overload resolution.

<P>In this case there are three constructors. The constructor which is
actually called is selected by the number and types of the parameters in
the definition. In line 78 of the main program the three objects are declared,
each with a different number of parameters and inspection of the results
will indicate that the correct constructor was called based on the number
of parameters.

<P>In the case of the other overloaded methods, the number and type of
parameters is clearly used to select the proper method. You will notice
that one method uses a single integer and another uses a single float type
variable, but the system is able to select the correct one. As many overloadings
as desired can be used provided that all of the parameter patterns are
unique.

<P>You may be thinking that this is a silly thing to do but it is, in fact,
a very important topic. Throughout this tutorial we have been using an
overloaded operator and you haven't been the least confused over it. It
is the &lt;&lt; operator which is part of the <B>cout </B>class, which
operates as an overloaded function since the way it outputs data is a function
of the type of its input variable or the field we ask it to display. Many
programming languages have overloaded output functions so you can output
any data with the same function name.

<P>Be sure to compile and execute this program.

<P><B>SEPARATE COMPILATION</B>

<P>Separate compilation is available with C++ and it follows the identical
rules as given for ANSI-C separate compilation. As expected, separately
compiled files can be linked together. However, since classes are used
to define objects, the nature of C++ separate compilation is considerably
different from that used for ANSI-C. This is because the classes used to
create the objects are not considered as external variables, but as included
classes. This makes the overall program look different from a pure ANSI-C
program. Your programs will take on a different appearance as you gain
experience in C++.

<P><B>YOU GET SOME METHODS BY DEFAULT</B>

<P>Example program ------> <B>DEFMETHS.CPP</B>

<P>Even if you include no constructors or operator overloadings you get
a few defined automatically by the compiler. Examine the file named DEFMETHS.CPP
which will illustrate those methods provided by the compiler, and why you
sometimes can't use the defaults but need to write your own to do the job
the defaults were intended to do for you.

<P>Before we actually look at the program, we will list a few rules that
all compiler writers must follow in order to deliver a useful implementation
of C++. First we will state the rules, then take a closer look at them
and the reason for their existence.
<OL>
<LI>
If no constructors are defined by the writer of a class, the compiler will
automatically generate a default constructor and a copy constructor. Both
of these constructors will be defined for you shortly.</LI>

<LI>
If the class author includes any constructor in the class, the default
constructor will not be supplied by the constructor.</LI>

<LI>
If the class author does not include a copy constructor, the compiler will
generate one, but if the writer includes a copy constructor, the compiler
will not generate one automatically.</LI>

<LI>
If the class author includes an assignment operator, the compiler will
not include one automatically, otherwise it will generate a default assignment
operator.</LI>
</OL>
Any class declared and used in a C++ program must have some way to construct
an object because the compiler, by definition, must call a constructor
when we define an object. If we don't provide a constructor, the compiler
itself will generate one that it can call during construction of the object.
This is the default constructor and we have used it unknowingly in a lot
of our example programs. The default constructor does not initialize any
of the member variables, but it sets up all of the internal class references
it needs, and calls the base constructor or constructors if they exist.
We haven't studied inheritance yet, but we will in the next chapter of
this tutorial so we will know then what base classes are all about. Line
12 of the present program declares a default constructor which is called
when you define an object with no parameters. In this case, the constructor
is necessary because we have an embedded string in the class that requires
a dynamic allocation and an initialization of the string to the null string.
It will take little thought to see that our constructor is much better
than the default constructor which would leave us with an uninitialized
pointer.

<P>The default constructor is used in line 79 of this example program.

<P><B>THE COPY CONSTRUCTOR</B>

<P>The copy constructor is generated automatically for you by the compiler
if you fail to define one yourself. It is used to copy the contents of
an object to a new object during construction of that new object. If the
compiler generates it for you, it will simply copy the contents of the
original into the new object as a byte by byte copy, which may not be what
you want. For simple classes with no pointers, that is usually sufficient,
but in the present example program, we have a pointer as a class member
so a byte by byte copy would copy the pointer from one to the other and
they would both be pointing to the same allocated member. For this program,
we declared our own copy constructor in line 15 and implemented it in lines
35 to 40. A careful study of the implementation will reveal that the new
class will indeed be identical to the original, but the new class has its
own string to work with. Since both constructors contain dynamic allocation,
we must assure that the allocated data is destroyed when we are finished
with the objects, so a destructor is mandatory as implemented in lines
51 through 54 of the present example program. The copy constructor is used
in line 85 of the current example program.

<P><B>THE ASSIGNMENT OPERATOR</B>

<P>It is not too obvious, but an assignment operator is required for this
program also, because the default assignment operator simply copies the
source object to the destination object byte by byte. This would result
in the same problem we had with copy constructor. The assignment operator
is declared in line 18 and defined in lines 42 through 49 where we deallocate
the old string in the existing object prior to allocating room for the
new text and copying the text from the source object into the new object.
The assignment operator is used in line 92.

<P>It should be fairly obvious to the student that when a class is defined
which includes any sort of dynamic allocation, the above three methods
should be included in addition to the proper destructor. If any of the
four entities are omitted, the program may have terribly erratic behavior.
Be sure to compile and execute this example program.

<P><B>A PRACTICAL EXAMPLE</B>

<P>Example program ------> <B>PHRASE.H</B>

<P>Using the <B>inline </B>keyword with a class member can cause a bit
of difficulty unless you understand how the compiler uses the inline code
definition to perform the inline code insertion. Examine the header file
named PHRASE.H which includes some inline methods. These are included as
an illustration of one means of defining the inline methods in a clean
way that the compiler can use efficiently.

<P>When any implementation uses this class, it must have access to the
inline implementation in order to insert the proper inline code for the
member functions. One way to do this is to put all of the inline methods
in a separate file named with the INL extension, then including that file
into the end of the .H file as shown here. This makes all of the inline
code available for the compiler while compiling files that use this class.

<P>Example program ------> <B>PHRASE.INL</B>

<P>The example file named PHRASE.INL contains all of the inline code for
this class.

<P>Example program ------> <B>PHRASE.CPP</B>

<P>Note that the only reason for this file to exist is to define the static
string variable <B>full_phrase</B>. Since this is a definition, and therefore
some memory is defined, it cannot be placed in the header file. If it were
placed there, it would seem to work all right in this program because the
header file is only used once, but using a bad technique like that would
lead to problems later. For illustrative purposes, all of the methods were
declared inline, so there are no member definitions in this class.

<P>Example program ------> <B>USEPHRAS.CPP</B>

<P>The file named USEPHRAS.CPP uses the <B>phrase </B>class defined in
the last two example files. It is plain to see that this class is no different
than any others we have studied. It simply illustrates a way to package
inline code in a simple and very efficient manner.

<P><B>ANOTHER PRACTICAL EXAMPLE</B>

<P>We come again to the practical part of this lesson where we study a
practical class that can actually be used in a program but is still simple
enough for the student to completely understand.

<P>Example program ------> <B>TIME.H</B>

<P>In the last chapter we studied the <B>date </B>class and in this chapter
we will study a simple <B>time </B>class. You should begin by studying
the file named TIME.H which will look very similar to the <B>date </B>class
header. The only major difference in this class from the <B>date </B>class
is the overloaded constructors and methods. The program is a very practical
example that illustrates very graphically that many constructor overloadings
are possible.

<P>Example program ------> <B>TIME.CPP</B>

<P>The implementation for the <B>time </B>class is given in the file named
TIME.CPP. Once again, the code is very simple and you should have no problem
understanding this example in its entirety. It should be pointed out that
three of the four overloadings actually call the fourth so that the code
did not have to be repeated four times. This is a perfectly good coding
practice and illustrates that other member functions can be called from
within the implementation.

<P>As we have mentioned before, this code contains calls that are specific
to DOS and are therefore not portable to other platforms. If you are using
some other platform, you will need to change the code to make valid calls
to your operating system, or simply assign default values to the member
variables.

<P>Example program ------> <B>USETIME.CPP</B>

<P>The example program named USETIME.CPP is a very simple program that
uses the <B>time </B>class in a very rudimentary way as an illustration
for you. You should be able to understand this program in a very short
time. It will be to your advantage to completely understand the practical
example programs given at the end of the last chapter and the end of this
chapter. As mentioned above, we will use the <B>time </B>class and the
<B>date </B>class as the basis for both single and multiple inheritance
in the next three chapters.

<P><B>WHAT SHOULD BE THE NEXT STEP?</B>

<P>At this point you have learned enough C++ to write meaningful programs
and it would be to your advantage to stop studying and begin using the
knowledge you have gained. Because C++ is an extension to ANSI-C, it can
be learned in smaller pieces than would be required if you are learning
a completely new language. You have learned enough to study and completely
understand the example program given in chapter 12, the Flyaway adventure
game. You should begin studying this program now.

<P>One of your biggest problems is learning to think in terms of object
oriented programming. It is not a trivial problem if you have been programming
in procedural languages for any significant length of time. However, it
can be learned by experience, so you should begin trying to think in terms
of classes and objects immediately. Your first project should use only
a small number of objects and the remainder of code can be completed in
standard procedural programming techniques. As you gain experience, you
will write more of the code for any given project using classes and objects
but every project will eventually be completed in procedural code.

<P>After you have programmed for a while using the techniques covered up
to this point in the tutorial, you can continue on to the next few chapters
which will discuss inheritance and virtual functions.

<P><B>PROGRAMMING EXERCISES</B>
<OL>
<LI>
Modify OBJDYNAM.CPP to make the objects named <B>small </B>and <B>medium
</B>pointers, then dynamically allocate them prior to using them.</LI>

<LI>
Modify the loop in line 62 of OBJLINK.CPP so that the loop will store 1000
elements in the list before stopping. You will probably wish to remove
the printout from line 81 so the program will stop in a reasonable time.
You may also get an integer overflow indicated by wrong answers if you
send a message to <B>get_area()</B> with such large numbers. That will
depend upon your compiler.</LI>

<LI>
Write a program that uses both the <B>date </B>and <B>time </B>classes
in a meaningful manner. No answer will be given in the ANSWERS directory
for this exercise since it is so straight forward. These classes can be
used in all of your future C++ programs to time stamp the time and date
of execution.</LI>
</OL>
<A HREF="Chap07.htm">Advance to Chapter 7</A>

<P><A HREF="C++Starter.htm">Return to Table of Contents</A>

<P>
<HR width="100%"><I><FONT SIZE=-1>Copyright &copy; 1989-1996 Coronado Enterprises
- Last update, September 22, 1996</FONT></I>
<BR><FONT SIZE=-1><I>Gordon Dodrill - dodrill@swcp.com - </I><A HREF="mailto:dodrill@swcp.com">Please
email any comments or suggestions.</A></FONT>
</BODY>
</HTML>
